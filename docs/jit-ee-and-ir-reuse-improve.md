# JIT ExecuteEngine与IR Module重用优化

在项目的原型阶段，为了代码的简洁与直接，很多地方都使用了新实例实现相关功能。
包括JIT ExecuteEngine和IR Module两个大模块。

这种方式由于大量使用了new操作，会浪费大量的内存与CPU资源。
本次改进的目的也是针对这两方面的，以提高现阶段该项目的可用性。

本文从优化的整体架构说明，到每个分模块一一介绍，到最后简单的测试，
希望能够对本次优化做到清晰说明。

### <h3>概要</h3>

为什么提高效率，优化内存使用，可行的方式就是资源的重用。

经过项目原型实现的分析，基本整理出来两个关系性比较强，可以重用的模块:
第一个是自动生成的IR代码的重用。
第二个是JIT执行引擎的重用。

以下所有的改进都是围绕这两个部分进行的。

### <h3>IR Module管理器模块</h3>
一旦要重用IR Module，那么生成的许多代码需要进行管理。
在原型实现中，对每次调用都会生成一个IR Module对象，包括了要调用的方法和该方法依赖的所有方法。
并且，每次调用执行完成后，IR Module对象都将销毁，即使是重复执行某个qt方法也是如此，虽然每次生成的IR代码都是相同的。
这就是我们要改进的地方。

本次改进方案主要思路是，每次调用需要生成新的IR Module对象时，生成后存储在IR Module管理器中。
后续再有相同的调用时，从IR Module管理器中取出存储的IR Module对象复用，
从而节省生成IR Module代码和对象的时间，提高执行效率。

这个模块通过name参数实现添加、删除、存在检测几个主要方法。
模块同时会操作JIT引擎的IR Module，但由于JIT引擎无法进行细粒度操作，需要同步执行。

### <h3>qtmod与remod拆分</h3>

这两个概念是从哪来的呢？
在原型实现中，生成的Qt相关的IR代码和手工生成的调用封装IR代码放在同一个IR Module对象中。
这种实现方式的代码比较简单直接，容易理解。

在考虑到实现IR Module重用优化后，这种方式不再适用了。
这是因为能重用的部分只是Qt代码生成的IR代码，而手工封装的调用代码每次参数不一样，
无法实现重用，所以要把这两部分区分开来。

在拆开后，与原型实现不同的一点，给IR Module对象一个有意义的名字，
这个名字表示该IR Module中包含了的入口symbol。
对qtmod来说，就是当前正在调用的方法的symbol名字，带qtmod前缀。
对remod来说，就是当前调用方法的封装的symbol名字，带remod前缀。

在实现了两个IR Module按功能拆分后，即可实现qtmod的重用了。
而remod封装了不同的this对象指针和不同的参数，每次行完后，还是需要销毁的。


### <h3>JIT引擎重用</h3>

这个模块也与之前的说明一样，从每次创建新的对象，到使用单实例模式，从而实现JIT代码的缓存重用功能。

这个JIT引擎与IR Module管理结合，实现重用的IR Module的管理功能。


### <h3>效果测试</h3>

对于执行方法一步，从原来的大概每次20-23ms，现在降低到12-13ms，
速度提高了~50%，效果还是非常明显的。


### <h3>问题</h3>

现在虽然有了非常明显的优化效果，但是多次生成的IR Module中依然可能有重复的代码。
也就是，重用的IR代码粒度依旧比较粗，没有达到最优的重用状态。
并且，由于不同的调用生成的是不同的IR Module对象，所有在程序执行过程中，
可能会生成成百上千个IR Module对象，依旧使用大量的内存资源。

MCJIT执行引擎的灵活性，可控制性还比较差，没有太多的控制功能，
无法对JIT引擎中已经生成的机器码做处理，有可能会消耗越来越多的内存。


