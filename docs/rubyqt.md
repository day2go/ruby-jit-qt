# Qt库的ruby语言绑定的探索与实现过程笔记

一直一来我经常使用Qt做一些简单的linux桌面工具软件，也算是对Qt库比较熟悉了。
而真正开始搞Qt库的ruby语言的绑定，出于当时觉得ruby是个比较有意思的编程语言，并开始接触学习ruby语言。
虽然在ruby最热门的时期作为web快速开发框架面世的，实现上我认为ruby也是一种非常不错的系统脚本语言。

在不断深入的学习ruby语言的过程中，越来越希望所有的开发工作都使用ruby语言实现，
并且这不只是希望，也尽可能的使用ruby完成一些开发工作。

不过，在这时，遇到一个需要更复杂的项目，希望能为这项目开发GUI界面功能。
经过一番网上搜索，也发现其实已经有qt的ruby语言绑定相关库了，
像kde项目中的rubyqt，还有qtbindings这个gem包，这两个包也比较成熟稳定了。
在试用的过程中了解到这两个包其实是同源的，并且都只支持Qt4版本。

由于qt5已经发布1,2年时间，也已经比较习惯用qt5开发了，所有用起来的时候总想着怎么让它们支持qt5。
这期间也试着对这两个项目做些升级工作，却发现也不是那么容易的。
因为qt5中大量使用了C++11新语法，新功能，而这两个项目的C++解析器很难完全处理这些新语法和新功能，
对于想让它们支持qt5的想法和尝试，最终以失败告终了。

虽然这个尝试失败了，不过在这期间，自己也考虑并尝试了很多方式，并且最终获得一种我认为非常好的实现方式。
由于这种方式与现有的实现方式是如此不同，并且让我学习到了很多，决定把这整个过程整理记录下来，
以备后续查阅，同时也为有兴趣的同行们抛砖引玉，实现更完善易用的ruby/qt开发库。

整个尝试并找到一个合适的方案的过程非常曲折，再加上本人写作水平有限，有描述不清晰还请轻拍。

### 第一阶段，手工编写ruby的C/C++扩展
这一阶段，是最开始的简单想法。当时考虑的是在编写程序的时候，遇到哪些用到的方法，就把它们手工添加到扩展中。
当然也试着编写了几个类的扩展，并且简单测试后确定该方式的可用性上也完全没有问题，效率也比较高。

这种实现方式大概需要几个步骤，
使用rb\_define\_class注册一个类到ruby运行时。
使用rb\_define\_method为新注册的类注册一个方法。
如果有多个方法的时候，则多次调用rb\_define\_method。
分别实现注册过的封装方法，调用C++的方法实现真实调用。

简单直白是这种方式的最大特点，所有的Qt类名与方法名都以明文的方式出现在扩展程序代码中，
容易编写实现，也容易阅读理解，是一种非常简单粗暴甚至好用的实现方式。

本着这思路，开始用扩展编写程序了，却发现来回为扩展添加类或者方法，再回头编写目标程序
来回切换实在实际使用时非常不理想，编写目标程序思路不断打断，而添加扩展类功能也像
是机械一样不断输入大量重复代码，越来越难以承受在这上面花费的机械而重复的工作了。

比如，对于每个类，都需要有构造方法和析构方法，而每个类的这些方法实际上非常相似，
但又不能说完全一样。即使能够采用一些变量或者参数的方式实现成一样，也不免要依赖
一些动态性质的编码了。

在这种状态下纠结着写了部分类的扩展之后，实在是难以忍受了。大概总结是，qt中有上千个类，
每个类又会有20，30甚至更多的方法，工作量之大已经到了无法实现的地步了。
思来想去，还是编写一个程序，来生成这些大量重复的代码好了，这种方式蒋在下一节中进行详细探索。

虽然在这花费了许多时间，也不是完全没有收获的，在这个尝试过程中逐渐对以下几个方面有了进一步的理解：
熟悉了编写ruby扩展的基本方法。
总结出了会包含大量重复代码的点。
对整体工作量有大体概念。
对最终要产生的扩展目标有了更清晰的概念。


### 第二阶段，编写代码生成工具，自动生成部分重复代码


### 第三阶段，使用swig的语言绑定包


### 第四阶段，使用Qt meta机制，实现动态的方法调用


### 第五阶段，预告整理出Qt共享库中的C++ symbol并执行


### 第六阶段，动态解析并匹配Qt共享库中的C++ symbol并执行


### 第七阶段，使用clang自动把生成的C++绑定代码编译为执行代码


### 第八阶段，手工翻译生成IR代码，使用LLVM的MCJIT执行


### 第九阶段，使用clang自动把C++ inline方法翻译为IR代码，并使用LLVM的MCJIT执行

感觉真像历经九九八十一难，终于看到光明了啊。


