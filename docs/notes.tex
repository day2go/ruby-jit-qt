\section{TODO列表}


\section{默认参数值的传递表达}
\subsection{普通类型}
这种类型包括内置类型，int,char,QVariant支持的类。
这种可以直接使用QVariant表示，并且能够非常容易的检测。

\subsection{表达式参数值}
这种包括类似QChar(' '), QString("")，QFlags<???>()，
在FrontEngine中转换打包这个表达式，
传递到CompilerEngine进行编译相应的表达式，并传递到OperatorEngine中引用表达式结果。
表达式的结果应该在CompilerEngine中生成，因为底层不应该再调用上层。
不过这个表达式代码还是挺难生成的。

默认值表达式生成的执行逻辑优化：
1、目前是在FE中，检测表达式中的类类型，在AST查找时就明确生成这个类的实例，把这个类传递到IR生成类OE中使用。
这种实现没有灵活性，并且需要在后续的测试中不断加入新的默认值类型的处理。
2、现在，已经使用了更优化的方式，为默认值表达式生成一段IR代码，传递到IR生成类OE中使用。
一般默认值表达式不会太复杂，生成的IR代码也比较简单，也容易处理使用。
3、也许，后续还可以把这些默认值表达式缓存，把生成的IR代码也缓存，不需要每次使用的时候都重复处理了。

// 发现了点东西，拷贝IR指令时需要注意的。
/*
  可能就是api中说的，clone出来的Inst与原来的Inst有点不一样，没有Parent
  以下两名都能生成相同的一行指令，但前者生成的语句就会导致崩溃，后者生成的则无问题
  call void @_ZN6QFlagsIN2Qt10WindowTypeEEC2EMNS2_7PrivateEi(%class.QFlags* %toargx0, i32 -1)
  call void @_ZN6QFlagsIN2Qt10WindowTypeEEC2EMNS2_7PrivateEi(%class.QFlags* %toargx0, i32 -1)
*/


\subsection{void*类型}
这种是一个透明传递的QXxx*类型实例。

\section{模板方法的实例化}
\subsection{普通方法实例化}
\subsection{构造函数实例化}
默认情况下会生成Ctor\_Complete类型的实例。

\section{调用重载函数的查找确认}
查找最合适的调用函数。
这个应该在clang中有，不知道在哪？

基础原理，计算重载函数的参数匹配度，使用匹配度最高的那个。
匹配度计算，参数是否匹配。
1。名字匹配
2。对于构造，如果调用提供了参数，则忽略默认构造函数
3。函数的参数个数不能少于调用提供的参数个数。

经过这3步的过滤，效果还是比较好的。


\section{返回的处理}

\section{类属性赋值的处理}
lcd.value = 5
lcd.range = 0..99
估计需要考虑检测是否是类的属性类型的symbol，再转换成相应的set函数调用。
ruby会生成一个"interval="方法调用，有一个参数为赋值表达式的方法调用。
这里的=号，无论在ruby离interval多远，都会被连接到property名字上当作一个方法名。

\section{类重载操作符的处理}
像==、!=、>、<等重载的操作符号。

\section{qApp全局变量的处理}
qtbinding中实例这个变量的方式是，通过继承出来一个假的Application或者CoreApplication类，
在这个类的初始化时设置ruby全局变量$qApp。

这种方式，实际也没有太多的技巧，也许可以考虑更好的方式。
使用rb\_define\_virtual\_variable方式，在C部分查找到相应的qApp并返回。
这是使用的尽量在C模块中集中实现所有的绑定功能，不需要在ruby中再做绑定的补丁。

\section{预编译头文件AST的应用}
可用。
不完善，修改了其中一个头文件，则需要重新生成ast文件。
如果实时生成，则速度太慢，上秒级。
可以考虑使用增量式的AST生成。

\chapter{Ruby&Qt}
\section{Ruby nil}
nil传递到Ruby C API之后会是什么类型的值，怎么表达的。
nil传递到C时是int类型的0。
区间0..99传递到Ruby C API之后会是什么类型，怎么表达的。
即Range类型(内部表示为T\_STRUCT类型)，需要扩展成两个参数：起始值与结束值。

\section{Ruby中继承Qt类的处理}

\section{Ruby的Object类已有方法的处理}
像display方法，如果在Qt类中还有这个方法，则无法正确的调用到Qt类的方法，
必须把Object类中的display方法undef掉，使用rb\_undef\_method函数。
类似的情况可能还有许多，但需要一个一个列出来。
这是还涉及到BasicObject类中的方法。
因为继承层次为BasicObject <- Object。

在ruby qtbinding项目中，它使用的是在ruby层重定义并覆盖这个方法的方式，
在qtruby4.rb文件中。
并且它使用的是覆盖整个Object类的方法，而不是针对某一个Qt类实例相应的修正。


\section{参考}
ROOT/cling
llvm/vmkit
Graal/Truffle

