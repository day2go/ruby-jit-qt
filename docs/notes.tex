\section{TODO列表}


\section{默认参数值的传递表达}
\subsection{普通类型}
这种类型包括内置类型，int,char,QVariant支持的类。
这种可以直接使用QVariant表示，并且能够非常容易的检测。

\subsection{表达式参数值}
这种包括类似QChar(' '), QString("")，QFlags<???>()，
在FrontEngine中转换打包这个表达式，
传递到CompilerEngine进行编译相应的表达式，并传递到OperatorEngine中引用表达式结果。
表达式的结果应该在CompilerEngine中生成，因为底层不应该再调用上层。
不过这个表达式代码还是挺难生成的。

默认值表达式生成的执行逻辑优化：
1、目前是在FE中，检测表达式中的类类型，在AST查找时就明确生成这个类的实例，把这个类传递到IR生成类OE中使用。
这种实现没有灵活性，并且需要在后续的测试中不断加入新的默认值类型的处理。
2、现在，已经使用了更优化的方式，为默认值表达式生成一段IR代码，传递到IR生成类OE中使用。
一般默认值表达式不会太复杂，生成的IR代码也比较简单，也容易处理使用。
3、也许，后续还可以把这些默认值表达式缓存，把生成的IR代码也缓存，不需要每次使用的时候都重复处理了。

// 发现了点东西，拷贝IR指令时需要注意的。
/*
  可能就是api中说的，clone出来的Inst与原来的Inst有点不一样，没有Parent
  以下两名都能生成相同的一行指令，但前者生成的语句就会导致崩溃，后者生成的则无问题
  call void @_ZN6QFlagsIN2Qt10WindowTypeEEC2EMNS2_7PrivateEi(%class.QFlags* %toargx0, i32 -1)
  call void @_ZN6QFlagsIN2Qt10WindowTypeEEC2EMNS2_7PrivateEi(%class.QFlags* %toargx0, i32 -1)
*/


\subsection{void*类型}
这种是一个透明传递的QXxx*类型实例。

\section{模板方法的实例化}
\subsection{普通方法实例化}
\subsection{构造函数实例化}
默认情况下会生成Ctor\_Complete类型的实例。

\section{返回的处理}

\section{类属性赋值的处理}
lcd.value = 5
lcd.range = 0..99
估计需要考虑检测是否是类的属性类型的symbol，再转换成相应的set函数调用。
ruby会生成一个"interval="方法调用，有一个参数为赋值表达式的方法调用。
这里的=号，无论在ruby离interval多远，都会被连接到property名字上当作一个方法名。

\section{预编译头文件AST的应用}
可用。
不完善，修改了其中一个头文件，则需要重新生成ast文件。
如果实时生成，则速度太慢，上秒级。
可以考虑使用增量式的AST生成。

\chapter{Ruby&Qt}
\section{Ruby nil}
nil传递到Ruby C API之后会是什么类型的值，怎么表达的。
nil传递到C时是int类型的0。
区间0..99传递到Ruby C API之后会是什么类型，怎么表达的。
即Range类型(内部表示为T\_STRUCT类型)，需要扩展成两个参数：起始值与结束值。

\section{Ruby中继承Qt类的处理}


\section{参考}
ROOT/cling
llvm/vmkit
Graal/Truffle

