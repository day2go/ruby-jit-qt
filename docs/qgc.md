### qgc工具设计与实现

##### 命名
这个工具的名字叫什么呢？
extract qt code and wrappter to cgo
可以叫qgc吧。总的来说是qt和cgo，或者是qt golang wrapper compiler。

##### 实现原理
实现Qt5的go语言绑定，需要一个工具，预先扫描项目的源代码，
然后自动生成与qt相关的对象创建，方法调用，函数调用的包装代码。
把生成的代码存储到文件，然后使用go build编译整个项目。

这个工具使用了go ast实现源代码的扫描遍历。
有一个问题是，go ast中没有很好的实现与类型的关联，而是以unresolved symbols形式存储在ast中。
当创建一个qt对象后，下次使用这个对象调用方法时，无法获取这个变量的类型，
分析过程无法直接判断是否是qt对象。



##### 变量类型推导
这里需要一个技巧，即，在创建qt对象语句中，把相应的变量存储起来，
在后续遇到这个对象时，根据这个存储结构，推导出这个变量的类型。
但这种方式有个问题，就是中间这个变量重新赋值的话，不知道是否能正确识别处理。

还有另一种方式，使用倒推方法，查找这个变量的定义语句，分析下是否是创建qt对象的语句。

目前看上去，可能第一种，效率更高些，因为它符合用空间换时间的条件，多占用了内存存储。

还有一种情况，是否有跨文件变量，是否能正确处理这种情况。


###### qt类方法返回值的处理
目前能想到的是全部返回interface{}类型。


##### qt对象的析构
目前能想到的是手工显式的调用free函数销毁qt对象。


###### 参数列表转换marshall


###### 支持的qt变量声明方式
1、v := qt.NewQxxx();
2、var v *qt.Qxxx; v = qt.NewQxxx();
3、var v qt.Qxxx;

其中3的声明方式如何处理还不太清晰，需要进一步分析整理。

##### qt方法重载的实现方式

go封装函数，使用变化参数，(args ...interface{})

1个go装装函数，需要对应n个C++封装方法，分别表示该方法的不同重载。

##### 编译生成代码标准规范



