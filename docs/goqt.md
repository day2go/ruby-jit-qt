# 实现Qt的go语言绑定的两种方式

Qt是一个成熟优秀的C++ GUI开发库，

### <h3>第一种方式</h3>

自动生成完整的cgo代码的方式。

基本原理，
使用一工具扫描使用了qt的go源代码，根据调用特征，生成完整的cgo封装代码。
生成的代码放在项目的目录树中，编译整个项目即可。

这种方式比较直接，编译出来的程序使用cgo的C包直接调用qt类和方法。
这中间完全没有动态处理过程，编译出来的最终程序效率还会比较好。
一个坏处生成的代码量还是比较大的，生成的代码也比较复杂，好在一个项目中可能用到的qt类和方法数量有限，应该可行。
另一个是由于注入了cgo，需要执行C++编译过程，速度比较慢，有点与go追求的极速编译冲突了。


### <h3>第二种方式</h3>

使用JIT在类虚拟机ruby-jit-qt后端上即时执行方式。

基本原理，
使用一工具扫描使用了qt的go源代码，根据调用特征，生成调用JIT后端的cgo封装代码。
生成的代码放在项目的目录树中，编译整个项目即可。

这种方向借用了ruby-jit-qt中的绑定思路，实现qt调用的动态执行，这是与第一种方式不同的地方。
相比较来说，这种方式更复杂，需要两步转换。
生成的cgo代码不再是直接使用cgo调用qt库方法，而是生成调用后端虚拟机的方法的cgo代码。
生成的cgo源代码部分，只是调用了虚拟机的几个方法，并且可以封装成c函数，所以编译速度会比较快。
由于插入了动态即时执行环节，编译出来的最终程序效率很可能会差些。
但是，这种方式生成的代码会比较简单，生成的代码量也会少很多，并且对预处理工具的要求低些。


### <h3>小结</h3>

由于go语言的静态特性，无法采用类似ruby语言的动态方法注册这类机制，
所以两种方式都需要一个额外的预处理工具，把go源代码中的qt调用解析出来，以实现动态qt绑定封装。

当然还有其他方式，修改golang的实现，给golang加一点动态特性，不过这个比较复杂，效果尚未可知，暂且不提。

